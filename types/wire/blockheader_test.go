// Copyright (c) 2013-2016 The btcsuite developers
// Copyright (c) 2020 The JaxNetwork developers
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

package wire

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"math"
	"math/big"
	"reflect"
	"testing"
	"time"

	"github.com/davecgh/go-spew/spew"
	"gitlab.com/jaxnet/jaxnetd/types/chainhash"
)

// TestBlockHeader tests the BlockHeader API.
func TestBlockHeader(t *testing.T) {
	nonce64, err := RandomUint64()
	if err != nil {
		t.Errorf("RandomUint64: Error generating nonce: %v", err)
	}
	nonce := uint32(nonce64)

	hash := mainNetGenesisHash
	merkleHash := mainNetGenesisMerkleRoot
	bits := uint32(0x1d00ffff)
	bh := NewBeaconBlockHeader(1, 1, hash, hash, merkleHash, hash, time.Now(), bits, big.NewInt(1), nonce)

	// Ensure we get the same data back out.
	if bh.PrevBlocksMMRRoot() != hash {
		t.Errorf("NewShardBlockHeader: wrong prev hash - got %v, want %v",
			spew.Sprint(bh.PrevBlocksMMRRoot), spew.Sprint(hash))
	}
	if bh.MerkleRoot() != merkleHash {
		t.Errorf("NewShardBlockHeader: wrong merkle root - got %v, want %v",
			spew.Sprint(bh.MerkleRoot), spew.Sprint(merkleHash))
	}
	if bh.Bits() != bits {
		t.Errorf("NewShardBlockHeader: wrong bits - got %v, want %v",
			bh.Bits(), bits)
	}
	if bh.Nonce() != nonce {
		t.Errorf("NewShardBlockHeader: wrong nonce - got %v, want %v",
			bh.Nonce(), nonce)
	}
}

// TestBlockHeaderSerialize tests BlockHeader serialize and deserialize.
func TestBeaconBlockHeaderSerialize(t *testing.T) {
	// baseBlockHdr is used in the various tests as a baseline BlockHeader.
	bits := uint32(0x1d00ffff)
	k := uint32(0x76100000)
	nonce := uint32(0x1e0f3)

	baseBlockHdr := &BeaconHeader{
		version:              1,
		height:               1,
		prevBlock:            mainNetGenesisHash,
		prevMMRRoot:          mainNetGenesisHash,
		merkleRoot:           mainNetGenesisMerkleRoot,
		bits:                 bits,
		k:                    k,
		voteK:                k,
		chainWeight:          big.NewInt(1),
		shards:               1,
		mergeMiningNumber:    1,
		mergeMiningRoot:      chainhash.HashH([]byte("mergeMiningRoot")),
		mergeMiningProof:     []chainhash.Hash{chainhash.HashH([]byte("mergeMiningRoot"))},
		treeEncoding:         []byte{0xDE, 0xAD, 0xBA, 0xBE},
		treeCodingLengthBits: 4,

		btcAux: BTCBlockAux{
			Version:    1,
			PrevBlock:  chainhash.HashH([]byte("PrevBlock")),
			MerkleRoot: chainhash.HashH([]byte("MerkleRoot")),
			Timestamp:  time.Unix(1645132389, 0),
			Bits:       bits,
			Nonce:      nonce,
			CoinbaseAux: CoinbaseAux{
				Tx: MsgTx{
					Version: 1,
					TxIn: []*TxIn{
						{
							PreviousOutPoint: OutPoint{
								Hash:  chainhash.HashH([]byte("PreviousOutPoint")),
								Index: 1,
							},
							SignatureScript: hexToBytes("03e1c720080000000000000000066a61786e6574" +
								"2003e818e664515a158c4eb0b99711cae6cee330724fcc76b64f59a1789eabf414" +
								"066a61786e65740e2f503253482f6a61786e6574642f"),
							Witness:  nil,
							Sequence: math.MaxInt32,
						},
					},
					TxOut: []*TxOut{
						{
							Value:    6_2500_0000,
							PkScript: hexToBytes("76a914bc473af4c71c45d5aa3278adc99701ded3740a5488ac"),
						},
					},
					LockTime: 0,
				},
				TxMerkleProof: nil,
			},
		},
	}

	// baseBlockHdrEncoded is the wire encoded bytes of baseBlockHdr.
	baseBlockHdrEncoded := []byte{
		0x6d,                   // magic byte of Beacon
		0x01, 0x00, 0x00, 0x00, // version 1
		0x01, 0x00, 0x00, 0x00, // block height 1
		0x6f, 0xe2, 0x8c, 0x0a, 0xb6, 0xf1, 0xb3, 0x72,
		0xc1, 0xa6, 0xa2, 0x46, 0xae, 0x63, 0xf7, 0x4f,
		0x93, 0x1e, 0x83, 0x65, 0xe1, 0x5a, 0x08, 0x9c,
		0x68, 0xd6, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, // prevMMRRoot

		0x6f, 0xe2, 0x8c, 0x0a, 0xb6, 0xf1, 0xb3, 0x72,
		0xc1, 0xa6, 0xa2, 0x46, 0xae, 0x63, 0xf7, 0x4f,
		0x93, 0x1e, 0x83, 0x65, 0xe1, 0x5a, 0x08, 0x9c,
		0x68, 0xd6, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, // prevBlock

		0x3b, 0xa3, 0xed, 0xfd, 0x7a, 0x7b, 0x12, 0xb2,
		0x7a, 0xc7, 0x2c, 0x3e, 0x67, 0x76, 0x8f, 0x61,
		0x7f, 0xc8, 0x1b, 0xc3, 0x88, 0x8a, 0x51, 0x32,
		0x3a, 0x9f, 0xb8, 0xaa, 0x4b, 0x1e, 0x5e, 0x4a, // merkleRoot

		0x61, 0x70, 0x7f, 0xe1, 0x72, 0x4c, 0xb7, 0x8a,
		0xc8, 0x1b, 0xed, 0x44, 0x8b, 0xc9, 0xba, 0xf6,
		0xf3, 0x6d, 0x2d, 0xe0, 0x9c, 0x9f, 0x6e, 0x7d,
		0xab, 0xf0, 0x95, 0xee, 0xd1, 0xbd, 0x28, 0xb6, // mergeMiningRoot

		0xff, 0xff, 0x00, 0x1d, // bits
		0x01, 0x00, 0x00, 0x00, // shards
		0x00, 0x00, 0x10, 0x76, // k
		0x00, 0x00, 0x10, 0x76, // voteK
		0x01, 0x00, 0x00, 0x00, //  mergeMiningNumber

		0x04, 0x00, 0x00, 0x00, // len of tree encoding
		0xde, 0xad, 0xba, 0xbe, // treeEncoding

		0x04, 0x00, 0x00, 0x00, // treeCodingLengthBits

		0x01, 0x01, 0x00, 0x00, 0x00, 0x01, // big.Int chainWeight

		0x01, // len of mergeMiningProof
		0x61, 0x70, 0x7f, 0xe1, 0x72, 0x4c, 0xb7, 0x8a,
		0xc8, 0x1b, 0xed, 0x44, 0x8b, 0xc9, 0xba, 0xf6,
		0xf3, 0x6d, 0x2d, 0xe0, 0x9c, 0x9f, 0x6e, 0x7d,
		0xab, 0xf0, 0x95, 0xee, 0xd1, 0xbd, 0x28, 0xb6, // mergeMiningProof

		0x01, 0x00, 0x00, 0x00, // version 1
		0xb6, 0x04, 0xcb, 0x98, 0x3a, 0xc8, 0xdf, 0x22,
		0xb3, 0x7c, 0x13, 0xca, 0x62, 0x43, 0xf4, 0x73,
		0xd4, 0x90, 0x52, 0xc4, 0x6d, 0xa9, 0xd0, 0x27,
		0x57, 0x04, 0x8e, 0x40, 0x4c, 0x18, 0xb3, 0x70, // PrevBlock

		0x7c, 0x19, 0x2e, 0x87, 0xba, 0x4c, 0xb6, 0xa9,
		0x58, 0xdd, 0xf3, 0x58, 0x56, 0xa4, 0xaf, 0x03,
		0x68, 0x00, 0x4a, 0x23, 0x9a, 0xb8, 0x7c, 0xf0,
		0xb7, 0x37, 0x32, 0x0d, 0x43, 0x14, 0x1f, 0x06, // MerkleRoot

		0x65, 0xba, 0x0e, 0x62, // Timestamp
		0xff, 0xff, 0x00, 0x1d, // Bits
		0xf3, 0xe0, 0x01, 0x00, // Nonce

		0x01, 0x00, 0x00, 0x00, // coinbase tx version
		0x01, // coinbase tx number of inputs
		0x9d, 0x96, 0xce, 0xa5, 0x62, 0x66, 0x49, 0x99,
		0x23, 0x3f, 0xa9, 0x5a, 0x36, 0x97, 0x9b, 0x50,
		0x6b, 0x18, 0x83, 0x41, 0x49, 0x1e, 0xe4, 0xfc,
		0xf4, 0xe5, 0x0a, 0xdc, 0x19, 0xcb, 0xa0, 0x1f, // coinbase tx prev_out_hash
		0x01, 0x00, 0x00, 0x00, // coinbase tx prev_out_id
		0x4b, // coinbase tx  len of signature script
		0x03, 0xe1, 0xc7, 0x20, 0x08, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x6a, 0x61,
		0x78, 0x6e, 0x65, 0x74, 0x20, 0x03, 0xe8, 0x18,
		0xe6, 0x64, 0x51, 0x5a, 0x15, 0x8c, 0x4e, 0xb0,
		0xb9, 0x97, 0x11, 0xca, 0xe6, 0xce, 0xe3, 0x30,
		0x72, 0x4f, 0xcc, 0x76, 0xb6, 0x4f, 0x59, 0xa1,
		0x78, 0x9e, 0xab, 0xf4, 0x14, 0x06, 0x6a, 0x61,
		0x78, 0x6e, 0x65, 0x74, 0x0e, 0x2f, 0x50, 0x32,
		0x53, 0x48, 0x2f, 0x6a, 0x61, 0x78, 0x6e, 0x65,
		0x74, 0x64, 0x2f, // coinbase tx signature script
		0xff, 0xff, 0xff, 0x7f, // coinbase tx sequence
		0x01,                                           // number of outputs
		0x40, 0xbe, 0x40, 0x25, 0x00, 0x00, 0x00, 0x00, // coinbase tx value
		0x19,
		0x76, 0xa9, 0x14, 0xbc, 0x47, 0x3a, 0xf4, 0xc7,
		0x1c, 0x45, 0xd5, 0xaa, 0x32, 0x78, 0xad, 0xc9,
		0x97, 0x01, 0xde, 0xd3, 0x74, 0x0a, 0x54, 0x88,
		0xac, 0x00, 0x00, 0x00, 0x00,
		0x00,
	}

	tests := []struct {
		in  BeaconHeader // Data to encode
		out BeaconHeader // Expected decoded data
		buf []byte       // Serialized data
	}{
		{
			*baseBlockHdr,
			*baseBlockHdr,
			baseBlockHdrEncoded,
		},
	}

	t.Logf("Running %d tests", len(tests))
	for i, test := range tests {
		// Serialize the block header.
		var buf bytes.Buffer
		err := test.in.Serialize(&buf)
		if err != nil {
			t.Errorf("Serialize #%d error %v", i, err)
			continue
		}
		if !bytes.Equal(buf.Bytes(), test.buf) {
			t.Errorf("Serialize #%d\n got: %s want: %s", i,
				spew.Sdump(buf.Bytes()), spew.Sdump(test.buf))
			continue
		}

		// Deserialize the block header.
		var bh = BeaconHeader{}
		rbuf := bytes.NewReader(test.buf)
		err = bh.Read(rbuf)
		if err != nil {
			t.Errorf("Deserialize #%d error %v", i, err)
			continue
		}

		test.out.btcAux.CoinbaseAux.TxMerkleProof = []chainhash.Hash{}
		// assert.Equal(t, bh, test.out)
		if !reflect.DeepEqual(bh, test.out) {
			t.Errorf("Deserialize #%d\n got: %s want: %s", i,
				spew.Sdump(&bh), spew.Sdump(test.out))
			continue
		}
	}
}

func hexToBytes(s string) []byte {
	b, _ := hex.DecodeString(s)
	return b
}

// TestBlockHeaderSerialize tests BlockHeader serialize and deserialize.
func TestShardBlockHeaderSerialize(t *testing.T) {
	bits := uint32(0x1d00ffff)
	k := uint32(0x76100000)
	nonce := uint32(0x1e0f3)

	baseBlockHdr := ShardHeader{
		height:           1,
		prevBlock:        mainNetGenesisHash,
		prevMMRRoot:      mainNetGenesisHash,
		merkleRoot:       mainNetGenesisMerkleRoot,
		bits:             bits,
		chainWeight:      big.NewInt(1),
		shardMerkleProof: []chainhash.Hash{chainhash.HashH([]byte("shardMerkleProof_1"))},

		beaconHeader: BeaconHeader{
			version:              1,
			height:               1,
			prevBlock:            mainNetGenesisHash,
			prevMMRRoot:          mainNetGenesisHash,
			merkleRoot:           mainNetGenesisMerkleRoot,
			bits:                 bits,
			k:                    k,
			voteK:                k,
			chainWeight:          big.NewInt(1),
			shards:               1,
			mergeMiningNumber:    1,
			mergeMiningRoot:      chainhash.HashH([]byte("mergeMiningRoot")),
			mergeMiningProof:     []chainhash.Hash{chainhash.HashH([]byte("mergeMiningRoot"))},
			treeEncoding:         []byte{0xDE, 0xAD, 0xBA, 0xBE},
			treeCodingLengthBits: 4,

			btcAux: BTCBlockAux{
				Version:    1,
				PrevBlock:  chainhash.HashH([]byte("PrevBlock")),
				MerkleRoot: chainhash.HashH([]byte("MerkleRoot")),
				Timestamp:  time.Unix(1645132389, 0),
				Bits:       bits,
				Nonce:      nonce,
				CoinbaseAux: CoinbaseAux{
					Tx: MsgTx{
						Version: 1,
						TxIn: []*TxIn{
							{
								PreviousOutPoint: OutPoint{
									Hash:  chainhash.HashH([]byte("PreviousOutPoint")),
									Index: 1,
								},
								SignatureScript: hexToBytes("03e1c720080000000000000000066a61786e6574" +
									"2003e818e664515a158c4eb0b99711cae6cee330724fcc76b64f59a1789eabf414" +
									"066a61786e65740e2f503253482f6a61786e6574642f"),
								Witness:  nil,
								Sequence: math.MaxInt32,
							},
						},
						TxOut: []*TxOut{
							{
								Value:    6_2500_0000,
								PkScript: hexToBytes("76a914bc473af4c71c45d5aa3278adc99701ded3740a5488ac"),
							},
						},
						LockTime: 0,
					},
					TxMerkleProof: nil,
				},
			},
		},
		beaconCoinbase: CoinbaseAux{
			Tx: MsgTx{
				Version: 1,
				TxIn: []*TxIn{
					{
						PreviousOutPoint: OutPoint{
							Hash:  chainhash.HashH([]byte("PreviousOutPoint")),
							Index: 1,
						},
						SignatureScript: hexToBytes("03e1c720080000000000000000066a61786e6574" +
							"2003e818e664515a158c4eb0b99711cae6cee330724fcc76b64f59a1789eabf414" +
							"066a61786e65740e2f503253482f6a61786e6574642f"),
						Witness:  nil,
						Sequence: math.MaxInt32,
					},
				},
				TxOut: []*TxOut{
					{
						Value:    6_2500_0000,
						PkScript: hexToBytes("76a914bc473af4c71c45d5aa3278adc99701ded3740a5488ac"),
					},
				},
				LockTime: 0,
			},
			TxMerkleProof: []chainhash.Hash{chainhash.HashH([]byte("TxMerkleProof"))},
		},
	}

	// baseBlockHdrEncoded is the wire encoded bytes of baseBlockHdr.
	baseBlockHdrEncoded := []byte{
		0x73,                   // magic byte of Shard
		0x01, 0x00, 0x00, 0x00, // block height 1
		0x6f, 0xe2, 0x8c, 0x0a, 0xb6, 0xf1, 0xb3, 0x72,
		0xc1, 0xa6, 0xa2, 0x46, 0xae, 0x63, 0xf7, 0x4f,
		0x93, 0x1e, 0x83, 0x65, 0xe1, 0x5a, 0x08, 0x9c,
		0x68, 0xd6, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, // prevMMRRoot

		0x6f, 0xe2, 0x8c, 0x0a, 0xb6, 0xf1, 0xb3, 0x72,
		0xc1, 0xa6, 0xa2, 0x46, 0xae, 0x63, 0xf7, 0x4f,
		0x93, 0x1e, 0x83, 0x65, 0xe1, 0x5a, 0x08, 0x9c,
		0x68, 0xd6, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, // prevBlock

		0x3b, 0xa3, 0xed, 0xfd, 0x7a, 0x7b, 0x12, 0xb2,
		0x7a, 0xc7, 0x2c, 0x3e, 0x67, 0x76, 0x8f, 0x61,
		0x7f, 0xc8, 0x1b, 0xc3, 0x88, 0x8a, 0x51, 0x32,
		0x3a, 0x9f, 0xb8, 0xaa, 0x4b, 0x1e, 0x5e, 0x4a, // merkleRoot

		0xff, 0xff, 0x00, 0x1d, // bits
		0x01, 0x01, 0x00, 0x00, 0x00, 0x01, // big.Int chainWeight
		0x01, // len of mergeMiningProof
		0xaf, 0xda, 0xa9, 0x12, 0x04, 0xfc, 0xf3, 0x9d,
		0x42, 0xd3, 0x6a, 0xa9, 0x56, 0x20, 0x37, 0x0b,
		0x40, 0x73, 0x6e, 0xff, 0x4e, 0xa2, 0x5e, 0x22,
		0x81, 0x77, 0xcb, 0xd6, 0x6d, 0x96, 0x10, 0xe4, // shardMerkleProof

		0x6d,                   // magic byte of Beacon
		0x01, 0x00, 0x00, 0x00, // version 1
		0x01, 0x00, 0x00, 0x00, // block height 1
		0x6f, 0xe2, 0x8c, 0x0a, 0xb6, 0xf1, 0xb3, 0x72,
		0xc1, 0xa6, 0xa2, 0x46, 0xae, 0x63, 0xf7, 0x4f,
		0x93, 0x1e, 0x83, 0x65, 0xe1, 0x5a, 0x08, 0x9c,
		0x68, 0xd6, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, // prevMMRRoot

		0x6f, 0xe2, 0x8c, 0x0a, 0xb6, 0xf1, 0xb3, 0x72,
		0xc1, 0xa6, 0xa2, 0x46, 0xae, 0x63, 0xf7, 0x4f,
		0x93, 0x1e, 0x83, 0x65, 0xe1, 0x5a, 0x08, 0x9c,
		0x68, 0xd6, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, // prevBlock

		0x3b, 0xa3, 0xed, 0xfd, 0x7a, 0x7b, 0x12, 0xb2,
		0x7a, 0xc7, 0x2c, 0x3e, 0x67, 0x76, 0x8f, 0x61,
		0x7f, 0xc8, 0x1b, 0xc3, 0x88, 0x8a, 0x51, 0x32,
		0x3a, 0x9f, 0xb8, 0xaa, 0x4b, 0x1e, 0x5e, 0x4a, // merkleRoot

		0x61, 0x70, 0x7f, 0xe1, 0x72, 0x4c, 0xb7, 0x8a,
		0xc8, 0x1b, 0xed, 0x44, 0x8b, 0xc9, 0xba, 0xf6,
		0xf3, 0x6d, 0x2d, 0xe0, 0x9c, 0x9f, 0x6e, 0x7d,
		0xab, 0xf0, 0x95, 0xee, 0xd1, 0xbd, 0x28, 0xb6, // mergeMiningRoot

		0xff, 0xff, 0x00, 0x1d, // bits
		0x01, 0x00, 0x00, 0x00, // shards
		0x00, 0x00, 0x10, 0x76, // k
		0x00, 0x00, 0x10, 0x76, // voteK
		0x01, 0x00, 0x00, 0x00, //  mergeMiningNumber

		0x04, 0x00, 0x00, 0x00, // len of tree encoding
		0xde, 0xad, 0xba, 0xbe, // treeEncoding

		0x04, 0x00, 0x00, 0x00, // treeCodingLengthBits

		0x01, 0x01, 0x00, 0x00, 0x00, 0x01, // big.Int chainWeight

		0x01, // len of mergeMiningProof
		0x61, 0x70, 0x7f, 0xe1, 0x72, 0x4c, 0xb7, 0x8a,
		0xc8, 0x1b, 0xed, 0x44, 0x8b, 0xc9, 0xba, 0xf6,
		0xf3, 0x6d, 0x2d, 0xe0, 0x9c, 0x9f, 0x6e, 0x7d,
		0xab, 0xf0, 0x95, 0xee, 0xd1, 0xbd, 0x28, 0xb6, // mergeMiningProof

		0x01, 0x00, 0x00, 0x00, // version 1
		0xb6, 0x04, 0xcb, 0x98, 0x3a, 0xc8, 0xdf, 0x22,
		0xb3, 0x7c, 0x13, 0xca, 0x62, 0x43, 0xf4, 0x73,
		0xd4, 0x90, 0x52, 0xc4, 0x6d, 0xa9, 0xd0, 0x27,
		0x57, 0x04, 0x8e, 0x40, 0x4c, 0x18, 0xb3, 0x70, // PrevBlock

		0x7c, 0x19, 0x2e, 0x87, 0xba, 0x4c, 0xb6, 0xa9,
		0x58, 0xdd, 0xf3, 0x58, 0x56, 0xa4, 0xaf, 0x03,
		0x68, 0x00, 0x4a, 0x23, 0x9a, 0xb8, 0x7c, 0xf0,
		0xb7, 0x37, 0x32, 0x0d, 0x43, 0x14, 0x1f, 0x06, // MerkleRoot

		0x65, 0xba, 0x0e, 0x62, // Timestamp
		0xff, 0xff, 0x00, 0x1d, // Bits
		0xf3, 0xe0, 0x01, 0x00, // Nonce

		0x01, 0x00, 0x00, 0x00, // coinbase tx version
		0x01, // coinbase tx number of inputs
		0x9d, 0x96, 0xce, 0xa5, 0x62, 0x66, 0x49, 0x99,
		0x23, 0x3f, 0xa9, 0x5a, 0x36, 0x97, 0x9b, 0x50,
		0x6b, 0x18, 0x83, 0x41, 0x49, 0x1e, 0xe4, 0xfc,
		0xf4, 0xe5, 0x0a, 0xdc, 0x19, 0xcb, 0xa0, 0x1f, // coinbase tx prev_out_hash
		0x01, 0x00, 0x00, 0x00, // coinbase tx prev_out_id
		0x4b, // coinbase tx  len of signature script
		0x03, 0xe1, 0xc7, 0x20, 0x08, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x6a, 0x61,
		0x78, 0x6e, 0x65, 0x74, 0x20, 0x03, 0xe8, 0x18,
		0xe6, 0x64, 0x51, 0x5a, 0x15, 0x8c, 0x4e, 0xb0,
		0xb9, 0x97, 0x11, 0xca, 0xe6, 0xce, 0xe3, 0x30,
		0x72, 0x4f, 0xcc, 0x76, 0xb6, 0x4f, 0x59, 0xa1,
		0x78, 0x9e, 0xab, 0xf4, 0x14, 0x06, 0x6a, 0x61,
		0x78, 0x6e, 0x65, 0x74, 0x0e, 0x2f, 0x50, 0x32,
		0x53, 0x48, 0x2f, 0x6a, 0x61, 0x78, 0x6e, 0x65,
		0x74, 0x64, 0x2f, // coinbase tx signature script
		0xff, 0xff, 0xff, 0x7f, // coinbase tx sequence
		0x01,                                           // number of outputs
		0x40, 0xbe, 0x40, 0x25, 0x00, 0x00, 0x00, 0x00, // coinbase tx value
		0x19,
		0x76, 0xa9, 0x14, 0xbc, 0x47, 0x3a, 0xf4, 0xc7,
		0x1c, 0x45, 0xd5, 0xaa, 0x32, 0x78, 0xad, 0xc9,
		0x97, 0x01, 0xde, 0xd3, 0x74, 0x0a, 0x54, 0x88,
		0xac, 0x00, 0x00, 0x00, 0x00,
		0x00,

		0x01, 0x00, 0x00, 0x00, // coinbase tx version
		0x01, // coinbase tx number of inputs
		0x9d, 0x96, 0xce, 0xa5, 0x62, 0x66, 0x49, 0x99,
		0x23, 0x3f, 0xa9, 0x5a, 0x36, 0x97, 0x9b, 0x50,
		0x6b, 0x18, 0x83, 0x41, 0x49, 0x1e, 0xe4, 0xfc,
		0xf4, 0xe5, 0x0a, 0xdc, 0x19, 0xcb, 0xa0, 0x1f, // coinbase tx prev_out_hash
		0x01, 0x00, 0x00, 0x00, // coinbase tx prev_out_id
		0x4b, // coinbase tx  len of signature script
		0x03, 0xe1, 0xc7, 0x20, 0x08, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x6a, 0x61,
		0x78, 0x6e, 0x65, 0x74, 0x20, 0x03, 0xe8, 0x18,
		0xe6, 0x64, 0x51, 0x5a, 0x15, 0x8c, 0x4e, 0xb0,
		0xb9, 0x97, 0x11, 0xca, 0xe6, 0xce, 0xe3, 0x30,
		0x72, 0x4f, 0xcc, 0x76, 0xb6, 0x4f, 0x59, 0xa1,
		0x78, 0x9e, 0xab, 0xf4, 0x14, 0x06, 0x6a, 0x61,
		0x78, 0x6e, 0x65, 0x74, 0x0e, 0x2f, 0x50, 0x32,
		0x53, 0x48, 0x2f, 0x6a, 0x61, 0x78, 0x6e, 0x65,
		0x74, 0x64, 0x2f, // coinbase tx signature script
		0xff, 0xff, 0xff, 0x7f, // coinbase tx sequence
		0x01,                                           // number of outputs
		0x40, 0xbe, 0x40, 0x25, 0x00, 0x00, 0x00, 0x00, // coinbase tx value
		0x19,
		0x76, 0xa9, 0x14, 0xbc, 0x47, 0x3a, 0xf4, 0xc7,
		0x1c, 0x45, 0xd5, 0xaa, 0x32, 0x78, 0xad, 0xc9,
		0x97, 0x01, 0xde, 0xd3, 0x74, 0x0a, 0x54, 0x88,
		0xac, 0x00, 0x00, 0x00, 0x00,
		0x01,
		0x57, 0x98, 0x10, 0x5f, 0xcf, 0x22, 0x9f, 0xc9,
		0x71, 0xfd, 0xa7, 0x1f, 0x45, 0x0e, 0x40, 0x66,
		0x61, 0x20, 0x68, 0xfd, 0x26, 0x1a, 0x81, 0xcd,
		0x9c, 0x11, 0xf0, 0xfd, 0xde, 0x35, 0x6b, 0x18,
	}

	tests := []struct {
		in  ShardHeader // Data to encode
		out ShardHeader // Expected decoded data
		buf []byte      // Serialized data
	}{
		{
			baseBlockHdr,
			baseBlockHdr,
			baseBlockHdrEncoded,
		},
	}

	t.Logf("Running %d tests", len(tests))
	for i, test := range tests {
		// Serialize the block header.
		var buf bytes.Buffer
		err := test.in.Serialize(&buf)
		if err != nil {
			t.Errorf("Serialize #%d error %v", i, err)
			continue
		}
		if !bytes.Equal(buf.Bytes(), test.buf) {
			for _, b := range buf.Bytes() {
				fmt.Printf("0x%02x, ", b)
			}
			t.Errorf("Serialize #%d\n got: %s want: %s", i,
				spew.Sdump(buf.Bytes()), spew.Sdump(test.buf))
			continue
		}

		// Deserialize the block header.
		var bh = ShardHeader{}

		rbuf := bytes.NewReader(test.buf)
		err = bh.Read(rbuf)
		if err != nil {
			t.Errorf("Deserialize #%d error %v", i, err)
			continue
		}

		test.out.beaconHeader.btcAux.CoinbaseAux.TxMerkleProof = []chainhash.Hash{}
		if !reflect.DeepEqual(bh, test.out) {
			t.Errorf("Deserialize #%d\n got: %s want: %s", i,
				spew.Sdump(&bh), spew.Sdump(test.out))
			continue
		}
	}
}
